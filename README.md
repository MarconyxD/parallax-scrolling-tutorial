# English version
[Versão em Português](#Versão-em-Português)

# Tutorial for creating the Parallax Scrolling effect for 2D game backgrounds in Unity

In games, it is common to use effects that increase the immersion provided in order to make the player's experience something more impactful and memorable. 2D games run away from reality a little by limiting themselves to movements, most of the time, without depth, dimensionally speaking. However, there are some techniques that can provide a greater sense of reality, even for 2D-style games. One of these techniques is the effect generated by Parallax Scrolling.

Parallax Scrolling is based on dividing the background image into different images, so that each image composes a different layer of the backdrop. Following the movement of the camera, each layer should move more slowly, proportional to its depth. In this way, components of the background that are at a greater distance will move more slowly, while those that are closer will move faster. Such an effect will generate an illusion of depth for the user. This is a very effective computer graphics technique for increasing immersiveness.

To this end, this tutorial will present the basics for configurations and coding in Unity to implement this effect.

Therefore, it will be necessary to use a background image with several layers. If you already have one, feel free to use it. In this article, the Foggy Mountains Parallax Background asset available in the Unity Asset Store at the link https://assetstore.unity.com/packages/2d/textures-materials/foggy-mountains-parallax-background-142516#description will be used. Thanks to the author SimpleArt for making it available for free. Here is a link to the author's page https://assetstore.unity.com/publishers/41827.

Continuing, the background image to be used is shown below:

<p align="center">
<img width="600" src="/Figures/01.png" alt="Figure 01">
</p>

From this angle it is not possible to observe, but changing the visualization and separating the layers, we can observe that the image is composed of 8 different images. (Note: the original asset has 10 layers, but I deleted two of them)

<p align="center">
<img width="400" src="/Figures/02.png" alt="Figure 02">
</p>

It is important that the images are superimposed on the same coordinate and that each one is linked to a different layer. Therefore, add the images to the scene, place them overlapping and change the value of the Order in Layer parameter in the Sprite Renderer component of each one of them so that the background image receives the value 0 and the following ones receive greater values, such as 1, 2, 3 and so on, resulting in the highest value for the closest image.

<p align="center">
<img width="1000" src="/Figures/03.png" alt="Figure 03">
</p>

In my case, as I have 8 images, the one on the last layer received the value 0 and the closest one received the value 7.

<p align="center">
<img width="400" src="/Figures/04.png" alt="Figure 04">
</p>

The next step is to triple each image that makes up the background. This step is important because while one background is displayed by the camera, the others will be held in standby. This procedure is interesting so that there is no moment when the application runs out of background. Therefore, the three must be positioned side by side, so that they complete each other. Thus, assuming that the camera is going to the right and reaches the end of the background on the right, the background on the left will be moved to this position, in order to give continuity to the scene. This process is repeated infinitely, giving the user a false feeling that the background is endless. Therefore, the images must be approximated.

<p align="center">
<img width="800" src="/Figures/07.png" alt="Figure 07">
</p>

And place them so that they complete each other.

<p align="center">
<img width="800" src="/Figures/08.png" alt="Figure 08">
</p>

In the Hierarchy, it is interesting to organize the images on the left as being superior to those on the right, as follows:

<p align="center">
<img width="400" src="/Figures/09.png" alt="Figure 09">
</p>

With all the images in the scene, it's important to position the camera to the position you want for your application, as well as make the appropriate display settings. Then, create an Empty Object to be established as the parent object of all images. Likewise, this Empty Object must be added as associated with the Camera. In this case, an Empty Object with the name Background was added and the configuration in the scene was established as follows:

<p align="center">
<img width="400" src="/Figures/05.png" alt="Figure 05">
</p>

Now, for script creation, two main points need to be remembered:

1. Each layer should move at a different speed, following the camera. The layer at the bottom moves the slowest, while the one closest to the camera moves the fastest.
2. As the layers move at different speeds relative to the camera, at some point the camera will reach the end of the image. Therefore, the image must be generated again at this moment, maintaining the fluidity and continuity of the scenario.
  
In this case, create a new script. The name of the script was defined as Background. If you wish, you can use the same name.
The initial script settings will be kept with the libraries normally already added when creating a script and with the Start() function. Change the Update() function by changing its name to FixedUpdate(). In this case, the use of FixedUpdate() is recommended as it is a fixed timer. Since Update() will be called depending on the frame rate, it may vary in certain cases. The instability of this call can generate a discontinuity in the background generation, which is not interesting for our project. That's why it's necessary to use FixedUpdate() so that the background update is done at a constant speed.

First, let's start the main class by creating some variables:

```
private float length, startpos;
public float parallaxEffect;
public GameObject cam;
private Vector3 initialBackgroundPosition;
```

Now, explaining each of the variables:

- length: responsible for receiving the value of the total size in X of the image;
- startpos: will receive the value of the initial X coordinate of the image to which the script will be associated;
- parallaxEffect: public variable that will receive a value inversely proportional to the desired speed for the image. If the image is the slowest, it will receive the highest value. This value should range from 0 to 1;
- cam: a GameObject that will be associated with the application's main camera. Associating the image to the camera, we can make it follow its movement;
- initialBackgroundPosition: a Vector3 that will be associated with all images. It must be associated with the Empty Object that was created as a parent for all images.

Before continuing the script, we can already define the values of the public parameters. First, this script must be added as a component of each of the images that make up the background. In my case, I added this script as a component of each of the 8 background images.
Then, according to the image below, we determine the cam and parallaxEffect values.

<p align="center">
<img width="400" src="/Figures/06.png" alt="Figure 06">
</p>

For cam, just add the scene's main camera. For parallaxEffect, remember that a value inversely proportional to the desired speed for the image must be added. In this case, for each layer, the following values were added:

- 0: 1
- 1: 0.9
- 2: 0.8
- 3: 0.6
- 4: 0.5
- 5: 0.4
- 6: 0.2
- 7: 0.05

Then for the Start() function:

```
void Start()
    {
        startpos = transform.position.x;
        length = GetComponent<SpriteRenderer>().bounds.size.x;
        initialBackgroundPosition = transform.position;
    }
```

In this function, we are setting the values ​​of some of the variables:

- The startpos variable is receiving the value of the image's initial X coordinate by checking the value of the position parameter of the Transform component of the image itself, which the script is part of as a component.
- The variable length identifies the size of the X border of the image that was related to the variable itself.
- The variable initialBackgroundPosition receives the Vector3 value of the coordinates of the initial position of the image which the script is part of as a component.

Finally, for the FixedUpdate() function, it is necessary to deal with the most important parts of the code: the movement of the images and their renewal at the end of their segment.

First, this function must create two variables of type float each time it is called. The first will be the temp variable, responsible for calculating how far the background moves in relation to the camera by calculating the X position of the camera at the moment the function is called multiplied by 1 minus the value of the parallaxEffect variable. This way, the greater the value of parallaxEffect, the smaller the movement. The second variable will be dist, responsible for calculating the distance moved in space by calculating the multiplication of the X position of the camera at the moment the function is called by the value of the parallaxEffect variable.

```
float temp = (cam.transform.position.x * (1 - parallaxEffect));
float dist = (cam.transform.position.x * parallaxEffect); 
```

The dist variable is directly related to the movement of images with respect to the camera. Through this calculation it is possible to determine to which position the image should be moved, in order to follow the movement of the camera. This is done by checking the current position of the camera. As we have the initial positions of both the camera and the images already saved, we can determine the new initial position of the image from the movement of the camera. So, we use the line of code below, which updates the position of the image to which the script is related based on the sum of its initial position and the calculated value in dist. The positions in Y and Z remain the same, since the image only moves in the X axis.

```
transform.position = new Vector3(startpos + dist, initialBackgroundPosition.y, transform.position.z);
```

As explained initially, three images are being used. When the camera reaches the end of the image on the right, for example, the image on the left changes position, giving continuity to the image on the right. And so the process is carried out successively, creating an “infinite background sensation”, but it is just two backgrounds alternating on display for the camera.

By adding movement to the camera on the X axis, it will be possible to observe the result, as demonstrated in the video:

[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/XY4BeuGwTpw/0.jpg)](https://www.youtube.com/watch?v=XY4BeuGwTpw)

To perform a test, in a simple way, just add movement to the camera. Create a new script, called CameraMovement for example, and add the line of code below to the Update() or FixedUpdate() function.

```
transform.position = new Vector3(transform.position.x + 1, transform.position.y, transform.position.z);
```

This line of code adds 1 to the camera's X position at each Update performed.

## Conclusion

As it was possible to observe, the application of the Parallax Scrolling effect is very simple to be carried out in Unity, taking only a few minutes. It is a very useful mechanic that generates an extra immersiveness for the user, improving the gaming experience.

In case there is any doubt, the Background and CameraMovement scripts for testing are available in this repository.

# Versão em Português
[English Version](#English-version)

# Tutorial para criar o efeito Parallax Scrolling para fundos de jogos 2D no Unity

Nos games, é comum a utilização de efeitos que aumentam a imersão proporcionada a fim de tornar a experiência do jogador algo mais impactante e memorável. Os jogos 2D fogem um pouco da realidade por se limitarem a movimentos, na maioria das vezes, sem profundidade, dimensionalmente falando. Porém, existem algumas técnicas que podem proporcionar uma maior sensação de realidade, mesmo para jogos no estilo 2D. Uma dessas técnicas é o efeito gerado pelo Parallax Scrolling.

O Parallax Scrolling baseia-se na divisão da imagem de fundo em diferentes imagens, de forma que cada imagem componha uma camada diferente do cenário. Seguindo o movimento da câmera, cada camada deverá se mover mais lentamente, proporcional à sua profundidade. Desta forma, os componentes do fundo que estão mais distantes se moverão mais lentamente, enquanto os que estão mais próximos se moverão mais rapidamente. Tal efeito gerará uma ilusão de profundidade para o usuário. Esta é uma técnica de computação gráfica muito eficaz para aumentar a imersão.

Para tanto, este tutorial apresentará o básico de configurações e codificação no Unity para implementar este efeito.

Portanto, será necessário utilizar uma imagem de fundo com diversas camadas. Se você já possui uma, fique à vontade para usá-la. Neste artigo, o ativo Foggy Mountains Parallax Background disponível na Unity Asset Store no link https://assetstore.unity.com/packages/2d/textures-materials/foggy-mountains-parallax-background-142516#description será usado. Agradecimentos ao autor SimpleArt por disponibilizá-lo gratuitamente. Aqui está um link para a página do autor https://assetstore.unity.com/publishers/41827.

Continuando, a imagem de fundo a ser utilizada é mostrada abaixo:

<p align="center">
<img width="600" src="/Figures/01.png" alt="Figure 01">
</p>

Deste ângulo não é possível observar, mas mudando a visualização e separando as camadas, podemos observar que a imagem é composta por 8 imagens diferentes. (Observação: o ativo original possui 10 camadas, mas excluí duas delas).

<p align="center">
<img width="400" src="/Figures/02.png" alt="Figure 02">
</p>

É importante que as imagens estejam sobrepostas na mesma coordenada e que cada uma esteja vinculada a uma camada diferente. Portanto, adicione as imagens à cena, coloque-as sobrepostas e altere o valor do parâmetro Order in Layer no componente Sprite Renderer de cada uma delas para que a imagem de fundo receba o valor 0 e as seguintes recebam valores maiores, como como 1, 2, 3 e assim por diante, resultando no valor mais alto para a imagem mais próxima.

<p align="center">
<img width="1000" src="/Figures/03.png" alt="Figure 03">
</p>

No meu caso, como tenho 8 imagens, a da última camada recebeu o valor 0 e a mais próxima recebeu o valor 7.

<p align="center">
<img width="400" src="/Figures/04.png" alt="Figure 04">
</p>

O próximo passo é triplicar cada imagem que compõe o fundo. Esta etapa é importante porque enquanto um fundo é exibido pela câmera, os demais ficarão em espera. Este procedimento é interessante para que não haja nenhum momento em que a aplicação fique sem background. Portanto, os três devem ser posicionados lado a lado, para que se completem. Assim, supondo que a câmera esteja indo para a direita e chegue ao final do fundo à direita, o fundo à esquerda será deslocado para esta posição, a fim de dar continuidade à cena. Este processo é repetido infinitamente, dando ao usuário a falsa sensação de que o fundo é infinito. Portanto, as imagens devem ser aproximadas.

<p align="center">
<img width="800" src="/Figures/07.png" alt="Figure 07">
</p>

E coloque-os de forma que se completem.

<p align="center">
<img width="800" src="/Figures/08.png" alt="Figure 08">
</p>

Na Hierarquia, é interessante organizar as imagens da esquerda como superiores às da direita, da seguinte forma:

<p align="center">
<img width="400" src="/Figures/09.png" alt="Figure 09">
</p>

Com todas as imagens da cena, é importante posicionar a câmera na posição desejada para sua aplicação, bem como fazer as configurações de exibição adequadas. Em seguida, crie um Objeto Vazio para ser estabelecido como objeto pai de todas as imagens. Da mesma forma, este Objeto Vazio deve ser adicionado como associado à Câmera. Neste caso foi adicionado um Objeto Vazio com o nome Background e a configuração na cena foi estabelecida da seguinte forma:

<p align="center">
<img width="400" src="/Figures/05.png" alt="Figure 05">
</p>

Agora, para a criação do script, dois pontos principais precisam ser lembrados:

1. Cada camada deve se mover em uma velocidade diferente, seguindo a câmera. A camada inferior se move mais lentamente, enquanto a mais próxima da câmera se move mais rápido.
2. À medida que as camadas se movem em velocidades diferentes em relação à câmera, em algum ponto a câmera alcançará o final da imagem. Portanto, a imagem deve ser gerada novamente neste momento, mantendo a fluidez e continuidade do cenário.
  
Neste caso, crie um novo script. O nome do script foi definido como Background. Se desejar, você pode usar o mesmo nome.

As configurações iniciais do script serão mantidas com as bibliotecas normalmente já adicionadas ao criar um script e com a função Start(). Altere a função Update() trocando seu nome para FixedUpdate(). Neste caso, recomenda-se o uso de FixedUpdate() por se tratar de um temporizador fixo. Como Update() será chamado dependendo da taxa de quadros, ela pode variar em certos casos. A instabilidade desta chamada pode gerar uma descontinuidade na geração do background, o que não é interessante para o nosso projeto. Por isso é necessário utilizar FixedUpdate() para que a atualização em background seja feita em velocidade constante.

Primeiro, vamos iniciar a classe principal criando algumas variáveis:

```
private float length, startpos;
public float parallaxEffect;
public GameObject cam;
private Vector3 initialBackgroundPosition;
```

Agora, explicando cada uma das variáveis:

- comprimento: responsável por receber o valor do tamanho total em X da imagem;
- startpos: receberá o valor da coordenada X inicial da imagem à qual o script estará associado;
- parallaxEffect: variável pública que receberá um valor inversamente proporcional à velocidade desejada para a imagem. Se a imagem for a mais lenta, receberá o valor mais alto. Este valor deve variar de 0 a 1;
- cam: um GameObject que será associado à câmera principal da aplicação. Associando a imagem à câmera, podemos fazer com que ela acompanhe seu movimento;
- inicialBackgroundPosition: um Vector3 que será associado a todas as imagens. Deve estar associado ao Objeto Vazio que foi criado como pai para todas as imagens.

Antes de continuar o script, já podemos definir os valores dos parâmetros públicos. Primeiramente, esse script deve ser adicionado como componente de cada uma das imagens que compõem o fundo. No meu caso, adicionei este script como componente de cada uma das 8 imagens de fundo.

Então, conforme imagem abaixo, determinamos os valores de cam e parallaxEffect.

<p align="center">
<img width="400" src="/Figures/06.png" alt="Figure 06">
</p>

Para cam, basta adicionar a câmera principal da cena. Para parallaxEffect, lembre-se que deve ser adicionado um valor inversamente proporcional à velocidade desejada para a imagem. Neste caso, para cada camada, foram adicionados os seguintes valores:

- 0: 1
- 1: 0,9
- 2: 0,8
- 3: 0,6
- 4: 0,5
- 5: 0,4
- 6: 0,2
- 7: 0,05

Então para a função Start():

```
void Start()
    {
        startpos = transform.position.x;
        length = GetComponent<SpriteRenderer>().bounds.size.x;
        initialBackgroundPosition = transform.position;
    }
```

Nesta função estamos definindo os valores de algumas das variáveis:

- A variável startpos está recebendo o valor da coordenada X inicial da imagem verificando o valor do parâmetro position do componente Transform da própria imagem, do qual o script faz parte como componente.
- A variável comprimento identifica o tamanho da borda X da imagem que estava relacionada à própria variável.
- A variável inicialBackgroundPosition recebe o valor Vector3 das coordenadas da posição inicial da imagem da qual o script faz parte como componente.

Por fim, para a função FixedUpdate() é necessário tratar das partes mais importantes do código: a movimentação das imagens e sua renovação ao final do seu segmento.

Primeiro, este método deve criar duas variáveis ​​do tipo float cada vez que for chamado. A primeira será a variável temp, responsável por calcular a distância que o fundo se move em relação à câmera calculando a posição X da câmera no momento em que a função é chamada multiplicada por 1 menos o valor da variável parallaxEffect. Dessa forma, quanto maior o valor de parallaxEffect, menor será o movimento. A segunda variável será dist, responsável por calcular a distância percorrida no espaço calculando a multiplicação da posição X da câmera no momento em que a função é chamada pelo valor da variável parallaxEffect.

```
float temp = (cam.transform.position.x * (1 - parallaxEffect));
float dist = (cam.transform.position.x * parallaxEffect); 
```

A variável dist está diretamente relacionada ao movimento das imagens em relação à câmera. Através deste cálculo é possível determinar para qual posição a imagem deve ser deslocada, de forma a acompanhar o movimento da câmera. Isto é feito verificando a posição atual da câmera. Como temos as posições iniciais tanto da câmera quanto das imagens já salvas, podemos determinar a nova posição inicial da imagem a partir do movimento da câmera. Assim, utilizamos a linha de código abaixo, que atualiza a posição da imagem à qual o script está relacionado com base na soma de sua posição inicial e do valor calculado em dist. As posições em Y e Z permanecem as mesmas, pois a imagem só se move no eixo X.

```
transform.position = new Vector3(startpos + dist, initialBackgroundPosition.y, transform.position.z);
```

Conforme explicado inicialmente, três imagens estão sendo utilizadas. Quando a câmera chega ao final da imagem da direita, por exemplo, a imagem da esquerda muda de posição, dando continuidade à imagem da direita. E assim o processo é realizado sucessivamente, criando uma “sensação de fundo infinito”, mas são apenas dois fundos alternados no display da câmera.

Adicionando movimento à câmera no eixo X será possível observar o resultado, conforme demonstrado no vídeo:

[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/XY4BeuGwTpw/0.jpg)](https://www.youtube.com/watch?v=XY4BeuGwTpw)

Para realizar um teste, de forma simples, basta adicionar movimento à câmera. Crie um novo script, chamado CameraMovement por exemplo, e adicione a linha de código abaixo à função Update() ou FixedUpdate().

```
transform.position = new Vector3(transform.position.x + 1, transform.position.y, transform.position.z);
```

Esta linha de código adiciona 1 à posição X da câmera a cada atualização realizada.

## Conclusão

Como foi possível observar, a aplicação do efeito Parallax Scrolling é muito simples de ser realizada no Unity, demorando apenas alguns minutos. É uma mecânica muito útil que gera uma imersão extra ao usuário, melhorando a experiência de jogo.

Caso haja alguma dúvida, os scripts Background e CameraMovement para teste estão disponíveis neste repositório.
